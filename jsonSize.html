<!DOCTYPE html>
<!--suppress CssUnusedSymbol, HtmlFormInputWithoutLabel -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSON Size</title>
    <style>
        html {
            font-family: Arial, sans-serif;
            font-size: 1.3em;
            background-color: #999;
            overflow: hidden;
        }

        body {
            margin: 0;
            padding: 0;
        }

        textarea {
            padding: 10px;
        }

        .main-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .top-panel {
            width: 100vw;
            font-size: 0.7rem;
            background-color: #ccc;
            outline: #e2e2e2 groove medium;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        button {
            padding: 10px 15px;
            background-color: #61afef;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            margin: 0.5rem 0 0.5rem 0.5rem;
        }

        button:hover {
            background-color: #4a90e2;
        }

        .search-box {
            display: flex;
            flex-direction: row;
            align-items: center;
        }

        .search-input {
            width: 15vw;
            padding: 10px 6px;
            margin: 0 0.5rem;
        }

        .search-button {
            height: 30px;
            width: 30px;
            padding: 0;
            margin: 0;
        }

        .search-info {
            margin: 0;
            padding: 10px 0.2rem;
        }

        .filename {
            width: 20vw;
            height: 100%;
            cursor: pointer;
            color: #1654a3;
            font-weight: bold;
            padding: 0.9rem;
            margin: 0 0 0 0.5rem;
        }

        .filename:hover {
            color: #338cff;
        }

        .hints {
            width: 13rem;
            height: 100%;
            font-size: 0.6rem;
            line-height: 0.1rem;
            padding: 0 1rem;
            margin: 0;
            outline: #e2e2e2 groove medium;
        }

        .path-info {
            cursor: pointer;
            color: #1654a3;
            font-weight: bold;
            font-size: 0.7rem;
            padding: 0.2rem 20px;
            margin: 0;
            white-space: nowrap;
        }

        .path-info:hover {
            color: #0071ff;
        }

        .bottom-panel {
            width: 96.4vw;
            flex-grow: 1;
            overflow: auto;
            margin: 0 0.5vw 0.5vw;
            border: 0.3vw solid #444;
            border-radius: 18px;
            outline: #e2e2e2 groove medium;
        }

        .json-input {
        }

        .json-display {
            white-space: pre;
            font-family: monospace;
            background-color: #282c34;
            padding: 1vw;
            color: #f8f8f2;
        }

        .json-display:focus {
            border-color: #1111c6;
        }

        .json-container {
            width: fit-content;
            min-width: 96.4vw;
            outline: #333842 dotted thin;
        }

        .json-root-selected {
            background-color: #222;
            border: 1px dotted #FFF;
        }

        .json-container-hover {
            background-color: #111;
        }

        .json-margin {
            color: #999999;
        }

        .json-info-margin {
            color: #999999;
        }

        .json-key-group {
            cursor: pointer;
            color: #ffe2e3;
            font-weight: bold;
        }

        .json-key-group:hover {
            color: #62a6ff;
        }

        .json-key-value {
            cursor: pointer;
            color: #7da762;
        }

        .json-key-value:hover {
            font-weight: bold;
        }

        .json-border {
            cursor: pointer;
            color: #ff989f;
            font-weight: bold;
        }

        .json-border-clickable {
            cursor: pointer;
            color: #ff989f;
            font-weight: bold;
        }

        .json-border-clickable:hover {
            color: #338cff;
        }

        .json-number {
            color: #96ceff;
        }

        .json-string {
            color: #7fb1d5;
        }

        .json-string-clickable {
            cursor: pointer;
            color: #d57f7f;
        }

        .json-string-clickable:hover {
            color: #338cff;
        }

        .json-info-group-huge {
            color: #ff0000;
            font-weight: bold;
        }

        .json-info-group-big {
            color: #ff0000;
        }

        .json-info-group-middle {
            color: #ffde00;
        }

        .json-info-group-small {
            color: #31ad00;
        }

        .json-info-group-tiny {
            color: #4f7640;
        }

        .json-duplication-group {
            cursor: pointer;
            color: rgba(255, 152, 159, 0.6);
            margin-left: 16px;
            padding-left: 4px;
        }

        .json-duplication-group:hover {
            color: #ffcbce;
        }

        .json-duplication-value {
            cursor: pointer;
            color: #7fb1d5;
            margin-left: 16px;
            padding-left: 4px;
        }

        .json-duplication-value:hover {
            color: #338cff;
        }

        .found {
            font-weight: bold;
            color: white;
            background-color: #000;
            outline: #00ffed dashed thin;
        }

        .found_current {
            padding-top: 2px;
            padding-bottom: 2px;
            outline: #00ffed solid thin;
        }

        .json-placeholder-button {
            margin-right: 10px;
        }

        .json-placeholder-button::before {
            content: ' ';
        }

        .json-copy-button {
            cursor: pointer;
            color: #ffffff;
            margin-right: 10px;
        }

        .json-copy-button::before {
            content: '\00A9';
        }

        .gone {
            display: none;
        }

        .no-select {
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* Internet Explorer/Edge */
            user-select: none; /* Стандартное свойство */
        }

        .invisible {
            color: transparent;
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* Internet Explorer/Edge */
            user-select: none; /* Стандартное свойство */
        }

        .toast {
            position: fixed;
            left: 45%;
            bottom: 10%;
            z-index: 1;

            opacity: 0;
            transition: opacity 0.5s ease-in-out;

            background-color: #eee;
            border: 1px solid #ccc;
            border-radius: 18px;
            outline: #e2e2e2 groove medium;
            padding: 15px;
        }

        .toast-visible {
            opacity: 1;
        }

        .div-horizontal {
            display: flex;
            flex-direction: row;
            align-items: center;
            padding: 0;
            margin: 0;
        }

        .div-vertical {
            display: flex;
            flex-direction: column;
            padding: 0;
            margin: 0;
        }

        .div-vertical-centered {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0;
            margin: 0;
        }

        .settings-box {
            font-size: 0.6rem;
            padding: 0 1rem;
            margin: 0;
        }
    </style>
</head>
<body>
<div class="main-container">
    <div class="top-panel">
        <div>
            <button id="displayJSON-button" onclick="displayJSON()">Display JSON</button>
            <button id="formatJSON-button" onclick="formatJSON()">Format</button>
            <button id="toText-button" onclick="toText()">to Text</button>
        </div>
        <div id="search-box" class="search-box">
            <input id="search-input" class="search-input" placeholder="Search by key or value. (not both at once)">
            <button id="search-back-button" class="search-button" onclick="search(-1)">&#9664;</button>
            <p id="search-info" class="search-info no-select" onclick="search()">&nbsp;&nbsp;-&nbsp;&nbsp;</p>
            <button id="search-button" class="search-button" onclick="search()">&#9654;</button>
        </div>
        <div>
            <input id="filename" class="filename" type="file" onchange="loadFile()"/>
        </div>
        <div id="settings-box" class="div-horizontal settings-box">
            <div class="div-vertical">
                <label>
                    <input id="is-search-case-sensitive" type="checkbox"> Case-sensitive search
                </label>
                <label>
                    <input id="is-copy-formatted-json" type="checkbox" checked> Copy formatted json
                </label>
            </div>
            <div class="div-vertical" style="margin-left: 1em;">
                <label>
                    <input id="is-show-info" type="checkbox" checked> Show info
                </label>
                <label>
                    <input id="is-sorting-by-size" type="checkbox" checked> Sort nodes by size
                </label>
            </div>
        </div>
        <div id="hints" class="hints">
            <p><b>Left click</b> - expand/collapse the node.</p>
            <p><b>Right click</b> - focus on the selected node.</p>
            <p>You can use <b>arrows</b> to navigate</p>
        </div>
    </div>

    <p id="path-info" class="path-info" title="Click to copy the path to the clipboard">&nbsp;</p>

    <div id="json-display" class="json-display bottom-panel" tabindex="0"></div>

    <textarea id="json-input" class="json-input bottom-panel" placeholder="Paste your JSON here...">{
    "name": "John",
    "age": 30,
    "married": true,
    "children": [
        {
            "name": "Mark",
            "age": 5
        },
        {
            "name": "Jane",
            "age": 10
        },
        {
            "name": "Mark",
            "age": 5
        }
    ],
    "pets": [],
    "address": {
        "street": "123 Main St",
        "city": "New York",
        "zip": {
            "num": 10001,
            "str": "10001"
        }
    }
}</textarea>
</div>

<div id="toast" class="toast"></div>

<script>
    const INDENT_SPACES = 4;
    const LINE_SYMBOL = '·' + ' '.repeat(INDENT_SPACES - 1); // '·' U+00B7 &#183; \00B7  |  '—' U+2014 &#8212; \2014
    const BUTTONS_WIDTH = 0;
    const STRING_LENGTH_LIMIT = 160;
    const STRING_LENGTH_CUT = 80;
    const STRING_SUB_LENGTH = STRING_LENGTH_CUT;

    function pair(a, b) {
        return {first: a, second: b};
    }

    function countOf(string, substring) {
        let count = -1;
        let index = -1;
        do {
            index = string.indexOf(substring, index + 1);
            count++;
        } while (index >= 0);

        return count;
    }

    function letKt(obj, action) {
        return action(obj);
    }

    function also(obj, action) {
        action(obj);
        return obj;
    }

    String.prototype.takeLast = function(num) {
        return this.substring(this.length - num, this.length);
    }

    Number.prototype.toHex = function(charCount = null) {
        let resultHex = Math.floor(this).toString(16);
        if (charCount != null) {
            resultHex = resultHex.takeLast(charCount)
        }
        resultHex = resultHex.toUpperCase();

        if (charCount == null || resultHex.length >= charCount) {
            return resultHex.toString();
        } else {
            return ('0'.repeat(charCount - resultHex.length) + resultHex).toString();
        }
    }

    String.prototype.fromHex = function() {
        return Number(`0x${this}`);
    }

    function isOnScreen(item) {
        const topMargin = 70;
        const rect = item.getBoundingClientRect();
        return rect.top >= topMargin && rect.left >= 0 && rect.bottom <= window.innerHeight && rect.right <= window.innerWidth;
    }

    async function getSHA256Hash(str) {
        const buf = new TextEncoder().encode(str);
        const digest = await crypto.subtle.digest('SHA-256', buf);
        return Array.from(new Uint8Array(digest))
            .map(b => b.toString(16).padStart(2, '0'))
            .join('');
    }

    async function shortHash(str, length = 8) {
        const hash = await getSHA256Hash(str);
        const hashStr = `${hash}`.toUpperCase();
        const shortHash = hashStr.substring(hashStr.length - length, hashStr.length);
        return `${shortHash.substring(0, length/2)}-${shortHash.substring(length/2, length)}`;
    }

    async function colorHash(str, length = 6) {
        const hash = await getSHA256Hash(str);
        const hashStr = `${hash}`.toUpperCase();
        const shortHash = hashStr.substring(hashStr.length - length, hashStr.length);
        return `${shortHash}`;
    }

    function invertHex(hex) {
        return (0xFFFFFF - hex.fromHex()).toHex(6);
    }

    function avgHex(hex) {
        const c1 = hex.substring(0, 2).fromHex();
        const c2 = hex.substring(2, 4).fromHex();
        const c3 = hex.substring(4, 6).fromHex();
        const avg = ((c1 + c2 + c3) / 3).toHex(2);
        return `${avg}${avg}${avg}`;
    }

    function subInvertHex(hex) {
        const c1 = hex.substring(0, 2).fromHex();
        const c2 = hex.substring(2, 4).fromHex();
        const c3 = hex.substring(4, 6).fromHex();
        const avg = (c1 + c2 + c3) / 3;
        const invertHex = (0xFF - avg).toHex(2);
        return `${invertHex}${invertHex}${invertHex}`;
    }

    function formatBytes(bytes) {
        if (bytes < 1024) {
            return bytes + " bytes";
        } else if (bytes < 1048576) {
            return (bytes / 1024).toFixed(2) + " KB";
        } else if (bytes < 1073741824) {
            return (bytes / 1048576).toFixed(2) + " MB";
        } else {
            return (bytes / 1073741824).toFixed(2) + " GB";
        }
    }

    function formatPercent(bytes, fullSize) {
        return (bytes * 100.0 / fullSize).toFixed(2) + '%';
    }

    function copyToClipboard(str) {
        navigator.clipboard.writeText(str).then(() => {
            showToast('Copied to clipboard...');
        }, (err) => {
            showToast('An error occurred while copying the text: ', err);
        });
    }

    function showToast(message) {
        const toast = document.getElementById('toast');
        toast.innerText = message
        toast.classList.add('toast-visible');
        setTimeout(function () {
            toast.classList.remove('toast-visible');
        }, 1000);
    }

    function getShortString(str) {
        return `"${str.replace('\n', '\\n').substring(0, STRING_LENGTH_CUT - 3)}..."`
    }

    function getFormattedString(str, margin = '') {
        let result = [];
        for (let i = 0; i < str.length; i += STRING_SUB_LENGTH) {
            result.push(str.slice(i, i + STRING_SUB_LENGTH));
        }
        return '"' + result.slice(0, result.length - 1).map((it) => {
            return it + '\n' + margin;
        }).join('') + result[result.length - 1] + '"';
    }

    function getParentPath(path) {
        const split = path.split('/');
        return split.slice(0, split.length - 1).join('/');
    }

    function elementIdToPath(keyId) {
        if (keyId != null && keyId.length > 0) {
            const split = keyId.split('(');
            if (split != null && split.length > 1) {
                const split2 = split[1].split(')');
                if (split2 != null && split2.length > 0) {
                    return split2[0];
                }
            }
        }
        return null;
    }

    function getLevelByPath(path) {
        if (path != null) {
            return path.split('/').length;
        }
        return 0;
    }

    function getRootId(path) {
        return `ROOT(${path})`;
    }

    function getKeyId(path) {
        return `KEY(${path})`;
    }

    function getGroupKey(path) {
        return `GROUP(${path})`;
    }

    function getValueKey(path) {
        return `VALUE(${path})`;
    }

    function findRootElement(path) {
        return document.getElementById(getRootId(path));
    }

    function findKeyElement(path) {
        return document.getElementById(getKeyId(path));
    }

    function findGroupElement(path) {
        return document.getElementById(getGroupKey(path));
    }

    function findValueElement(path) {
        return document.getElementById(getValueKey(path));
    }

    function createTreeElement(path, key, value, sizeOut, fullSize, level = 0, isLast = true, isParentArray = false) {
        const isGroup = typeof value === 'object' && value !== null;
        const isArray = Array.isArray(value);

        const indentSpaces = BUTTONS_WIDTH + level * INDENT_SPACES;
        const marginBegin = dotLine(indentSpaces + (isGroup ? -BUTTONS_WIDTH : 0));

        const container = document.createElement('div');
        container.classList.add('json-container');
        container.addEventListener('mouseover', function(event) {
            event.stopPropagation();
            container.classList.add('json-container-hover');
        });
        container.onmouseout = (e) => {
            container.classList.remove('json-container-hover');
        }
        container.id = getRootId(path);
        const copyButton = document.createElement('span');
        copyButton.classList.add('json-copy-button');
        copyButton.setAttribute('title', 'Click to copy this node to the clipboard');
        const keyElement = document.createElement('span');
        keyElement.id = getKeyId(path);
        const marginElement = document.createElement('span');
        marginElement.classList.add('json-margin');
        const infoMarginElement = document.createElement('span');
        infoMarginElement.classList.add('json-info-margin');
        const infoElement = document.createElement('span');
        infoElement.classList.add('json-info');

        const keyStr = key ? `${key}` : '';
        const delimStr = key ? `: ` : '';
        const keySize = (key && !isParentArray) ? 1/*"*/ + key.length + 1/*"*/ + 1/*:*/ : 0;

        const valueFullStr = JSON.stringify(value);
        const valueFullSize = valueFullStr.length;
        const mySize = keySize + valueFullSize + (isLast ? 0 : 1)/*,*/;
        sizeOut.value = mySize;

        let beforeInfoLen = marginBegin.length + keyStr.length + delimStr.length;
        marginElement.textContent = marginBegin

        if (isGroup) {
            keyElement.classList.add('json-key-group');
            keyElement.textContent = keyStr;
            const borderElement = document.createElement('span');
            borderElement.classList.add('json-border');
            const valueElement = document.createElement('div');
            valueElement.id = getGroupKey(path);
            const closureInlineElement = document.createElement('span');
            closureInlineElement.classList.add('json-border');
            const duplicationElement = document.createElement('span');
            duplicationElement.classList.add('json-duplication-group', 'no-select');
            const closureMarginElement = document.createElement('span');
            closureMarginElement.classList.add('json-margin');
            const placeholderButton = document.createElement('span');
            placeholderButton.classList.add('json-placeholder-button');
            const closureElement = document.createElement('span');
            closureElement.classList.add('json-border-clickable');

            // ---

            if (level === 0) {
                appendValueChildren(path, value, valueElement, fullSize, level, isArray);
            }
            const closureElements = [valueElement, closureMarginElement, closureElement];
            const closureElementsNegative = [closureInlineElement];
            onExpandCollapse(level === 0, closureElements, closureElementsNegative);

            keyElement.onclick = () => {
                const toExpand = isCollapsed(valueElement);
                makeExpandCollapse(toExpand, path, value, fullSize, level, isArray, valueElement, closureElements, closureElementsNegative);
                markKeySelected(path);
            };
            borderElement.onclick = keyElement.onclick;
            closureInlineElement.onclick = keyElement.onclick;
            closureElement.onclick = keyElement.onclick;
            marginElement.onclick = () => {
                markKeySelected(path);
            };
            infoMarginElement.onclick = marginElement.onclick;
            infoElement.onclick = marginElement.onclick;

            keyElement.oncontextmenu = () => {
                focusThis(path, key, value);
                return false;
            };

            const childCount = Object.keys(value).length;
            const borderStartStr = isArray ? '[' : '{';
            beforeInfoLen += BUTTONS_WIDTH + borderStartStr.length + `${childCount}`.length + 2/*},*/;

            borderElement.textContent = delimStr + borderStartStr;
            closureInlineElement.textContent = childCount + (isArray ? ']' : '}') + ',';
            closureMarginElement.textContent = dotLine(indentSpaces);
            closureElement.textContent = (isArray ? ']' : '}') + ',';

            const isDuplication = countDuplications(
                duplicationElement, valueFullStr, valueFullSize, fullSize,
                () => {
                    const isCopyFormattedJson = document.getElementById('is-copy-formatted-json').checked;
                    if (isCopyFormattedJson) {
                        copyToClipboard(JSON.stringify(JSON.parse(valueFullStr), null, '    '));
                    } else {
                        copyToClipboard(valueFullStr);
                    }
                }
            );

            // ---
            container.appendChild(copyButton);
            container.appendChild(marginElement);
            container.appendChild(keyElement);
            container.appendChild(borderElement);
            container.appendChild(closureInlineElement);
            container.appendChild(infoMarginElement);
            container.appendChild(infoElement);
            if (isDuplication) {
                container.appendChild(duplicationElement);
            }
            container.appendChild(valueElement);
            container.appendChild(placeholderButton);
            container.appendChild(closureMarginElement);
            container.appendChild(closureElement);
        } else {
            const valueElement = document.createElement('span');
            valueElement.id = getValueKey(path);
            const duplicationElement = document.createElement('span');
            duplicationElement.classList.add('json-duplication-value', 'no-select');

            keyElement.onclick = () => {
                markKeySelected(path);
            };
            valueElement.onclick = keyElement.onclick;
            marginElement.onclick = keyElement.onclick;
            infoMarginElement.onclick = keyElement.onclick;
            infoElement.onclick = keyElement.onclick;

            let valueStr;
            let isDuplication = false;
            if (typeof value === 'string') {
                if (value.length > STRING_LENGTH_LIMIT) {
                    valueElement.classList.add('json-string-clickable');
                    valueStr = getShortString(value);
                    valueElement.onclick = () => {
                        const textContent = valueElement.textContent;
                        if (textContent.length < value.length) {
                            const additionalMargins = (keyStr.length + delimStr.length + 1/*"*/) / INDENT_SPACES;
                            valueElement.textContent = getFormattedString(
                                value, marginBegin + dotLine(BUTTONS_WIDTH + additionalMargins * INDENT_SPACES)
                            );
                        } else if (textContent.includes('\n')) {
                            valueElement.textContent = `"${value}"`;
                        } else {
                            valueElement.textContent = getShortString(value);
                        }
                        markKeySelected(path);
                    };
                } else {
                    valueElement.classList.add('json-string');
                    valueStr = `"${value}"`;
                }
                valueStr += (isLast ? '' : ',');

                isDuplication = countDuplications(
                    duplicationElement, valueFullStr, value.length, fullSize,
                    () => {
                        const searchInput = document.getElementById('search-input');
                        if (searchInput != null) {
                            searchInput.value = `${value}`;
                            search();
                        }
                    }
                );
            } else {
                valueElement.classList.add('json-number');
                valueStr = value + ',';
            }

            beforeInfoLen += valueStr.length;

            // ---
            keyElement.classList.add('json-key-value');
            keyElement.textContent = keyStr + delimStr;

            valueElement.textContent = valueStr;

            container.appendChild(copyButton);
            container.appendChild(marginElement);
            container.appendChild(keyElement);
            container.appendChild(valueElement);
            container.appendChild(infoMarginElement);
            container.appendChild(infoElement);
            if (isDuplication) {
                container.appendChild(duplicationElement);
            }
        }

        copyButton.onclick = () => {
            let nodeJson;
            if (level === 0 || keyStr.length === 0) {
                nodeJson = JSON.stringify(value);
            } else {
                nodeJson = '{' + `"${keyStr}"` + delimStr + JSON.stringify(value) + '}';
            }
            const isCopyFormattedJson = document.getElementById('is-copy-formatted-json').checked;
            if (isCopyFormattedJson) {
                copyToClipboard(JSON.stringify(JSON.parse(nodeJson), null, '    '));
            } else {
                copyToClipboard(nodeJson);
            }
            markKeySelected(path);
        }

        const infoBytes = formatBytes(mySize);
        infoMarginElement.textContent = marginAlignmentRight(infoBytes, beforeInfoLen);
        infoElement.textContent = infoBytes + ' | ' + formatPercent(mySize, fullSize);
        setInfoClass(infoElement, mySize, fullSize);

        updateInfoVisibility(container);

        return container;
    }

    function countDuplications(element, valueStr, valueSize, fullSize, actionClick = () => {}) {
        let duplicationStr = '';
        if (valueSize > 0) {
            try {
                const count = countOf(jsonString, valueStr);
                if (count > 1) {
                    const bytesStr = formatBytes(valueSize);
                    const bytesAll = count * valueSize;
                    const bytesAllStr = formatBytes(bytesAll);
                    const percentStr = formatPercent(bytesAll, fullSize);
                    duplicationStr = `Duplication: <b>${count}</b> times (${bytesStr} -> <b>${bytesAllStr}</b> ${percentStr})`;
                    element.innerHTML = duplicationStr;

                    colorHash(valueStr).then((it) => {
                        element.innerHTML += `<span style="color: ${'#' + it}"> #${it}</span>`;
                    });

                    element.onclick = actionClick;
                }
            } catch (e) {
                duplicationStr += 'Exception: ' + e.toString();
            }
        }
        return duplicationStr.length > 0;
    }

    function updateInfoVisibility(root = document, isShowInfo = document.getElementById('is-show-info').checked) {
        function updateInfoVisibilityInternal(className, classNameForModify = 'gone') {
            const items = root.getElementsByClassName(className);
            for (let i = 0; i < items.length; i++) {
                if (isShowInfo) {
                    items[i].classList.remove(classNameForModify);
                } else {
                    items[i].classList.add(classNameForModify);
                }
            }
        }

        updateInfoVisibilityInternal('json-copy-button');
        updateInfoVisibilityInternal('json-margin', 'invisible');
        updateInfoVisibilityInternal('json-info-margin');
        updateInfoVisibilityInternal('json-info');
        updateInfoVisibilityInternal('json-placeholder-button');
        updateInfoVisibilityInternal('json-duplication-group');
        updateInfoVisibilityInternal('json-duplication-value');
    }

    function isCollapsed(groupItem) {
        if (groupItem != null) {
            return groupItem.classList.contains('gone');
        } else return true;
    }

    function appendValueChildren(path, jsonValue, valueElement, fullSize, level, isArray) {
        const count = Object.keys(jsonValue).length;
        let i = 0;
        const valueChildren = [];
        const childrenSize = {
            value: 0
        };
        for (const k in jsonValue) {
            childrenSize.value = 0;
            const isLastChild = i === count - 1;
            const newPath = `${path}/${k}`;
            const child = createTreeElement(newPath, k, jsonValue[k], childrenSize, fullSize, level + 1, isLastChild, isArray)
            valueChildren.push(pair(childrenSize.value, child));
            i++;
        }

        const isSortingBySize = document.getElementById('is-sorting-by-size').checked;
        if (isSortingBySize) {
            valueChildren.sort((a, b) => b.first - a.first)
        }

        valueChildren.forEach((it) => {
            valueElement.appendChild(it.second);
        });
    }

    function onExpandCollapse(toExpand, closureElements, closureElementsNegative) {
        if (toExpand) {
            closureElements.forEach((it) => {
                it.classList.remove('gone');
            });
            closureElementsNegative.forEach((it) => {
                it.classList.add('invisible');
            });
        } else {
            closureElements.forEach((it) => {
                it.classList.add('gone');
            });
            closureElementsNegative.forEach((it) => {
                it.classList.remove('invisible');
            });
        }
    }

    function makeExpandCollapse(toExpand, path, value, fullSize, level, isArray, valueElement, closureElements, closureElementsNegative) {
        if (toExpand && !valueElement.hasChildNodes()) {
            appendValueChildren(path, value, valueElement, fullSize, level, isArray);
        }
        onExpandCollapse(toExpand, closureElements, closureElementsNegative);
    }

    function makeExpandCollapseByPath(
        toExpand,
        path,
        nextAction = () => {
        }
    ) {
        if (path != null) {
            const keyElement = findKeyElement(path);
            if (keyElement != null) {
                const groupElement = findGroupElement(path);
                if (groupElement != null) {
                    if (isCollapsed(groupElement) === toExpand) {
                        keyElement.onclick(null);
                    } else {
                        nextAction();
                    }
                } else {
                    if (!toExpand) {
                        nextAction();
                    }
                }
            }
        }
    }

    function setInfoClass(infoElement, mySize, fullSize) {
        if (mySize > fullSize / 2) {
            infoElement.classList.add('json-info-group-huge');
        } else if (mySize > fullSize / 5) {
            infoElement.classList.add('json-info-group-big');
        } else if (mySize > fullSize / 7) {
            infoElement.classList.add('json-info-group-middle');
        } else if (mySize > fullSize / 10) {
            infoElement.classList.add('json-info-group-small');
        } else {
            infoElement.classList.add('json-info-group-tiny');
        }
    }

    function getInfoMarginSz(beforeInfo, infoMod = 20) {
        const beforeInfoMod = Math.floor(beforeInfo / infoMod + 1) * infoMod;
        return beforeInfoMod - beforeInfo;
    }

    let longDotLine = '';
    const oneLen = LINE_SYMBOL.length;

    function dotLine(charCount, fromStart = 0) {
        if (charCount === 0) return '';
        const fullLen = fromStart + charCount;
        if (longDotLine.length < fullLen) {
            longDotLine = LINE_SYMBOL.repeat(fullLen / oneLen + oneLen);
        }
        return longDotLine.substring(fromStart, fullLen - 1) + ' ';
    }

    function marginAlignmentRight(str, fromStart) {
        const extPadding = getInfoMarginSz(fromStart);
        const fullWidth = 16;
        const padding = Math.max(fullWidth - str.length, 0);
        return dotLine(padding + extPadding, fromStart);
    }

    function focusThis(path, key, node) {
        const display = document.getElementById('json-display');
        jsonString = `{"${key}":${JSON.stringify(node)}}`;
        try {
            json = JSON.parse(jsonString);
        } catch (e) {
            alert('Invalid JSON');
            return;
        }
        display.innerHTML = '';
        lastSearchRequest = '';
        let size = {
            value: 0
        };
        display.appendChild(createTreeElement('', '', json, size, jsonString.length));
    }

    function formatJSON() {
        const input = document.getElementById('json-input');

        let json;
        try {
            json = JSON.parse(input.value);
        } catch (e) {
            alert('Invalid JSON');
            return;
        }

        input.value = JSON.stringify(json, null, '    ');
        copyToClipboard(input.value);
    }

    function findInJson(json, request, path = '') {
        let requestStr;
        const isCaseSensitiveSearch = document.getElementById('is-search-case-sensitive').checked;
        if (isCaseSensitiveSearch) {
            requestStr = request;
        } else {
            requestStr = request.toUpperCase();
        }

        let result = '';
        const isArray = Array.isArray(json);

        for (const key in json) {
            const newPath = `${path}/${key}`;
            const value = json[key];

            if (!isArray) {
                let keyStr;
                if (isCaseSensitiveSearch) {
                    keyStr = key;
                } else {
                    keyStr = key.toUpperCase();
                }

                if (keyStr.includes(requestStr)) {
                    result += `${newPath};\n`;
                }
            }

            const isGroup = typeof value === 'object' && value !== null;
            if (isGroup) {
                result += findInJson(value, requestStr, newPath);
            } else {
                let valueStr;
                if (isCaseSensitiveSearch) {
                    valueStr = `${value}`;
                } else {
                    valueStr = `${value}`.toUpperCase();
                }

                if (valueStr.includes(requestStr)) {
                    result += `${newPath};\n`;
                }
            }
        }

        return result;
    }

    let lastSearchRequest = '';
    let lastSearchIndex = -1;

    function search(direction = 1) {
        function resetSearchMarks() {
            const lastFound = document.getElementsByClassName('found');
            for (let i = 0; i < lastFound.length; i++) {
                try {
                    lastFound[i].classList.remove('found_current', 'found');
                    lastFound[i].classList.remove('found_current', 'found');
                    lastFound[i].classList.remove('found_current', 'found');
                    lastFound[i].classList.remove('found_current', 'found');
                } catch (e) {
                }
            }
        }

        function resetSearch() {
            resetSearchMarks();
            lastSearchRequest = '';
            lastSearchIndex = -1;
            searchInfo.innerText = `\xa0\xa0-\xa0\xa0`;
        }

        const searchInput = document.getElementById('search-input');
        const searchInfo = document.getElementById('search-info');
        const request = searchInput.value;
        if (request.length === 0) {
            resetSearch();
            return;
        }

        const results = findInJson(json, request).split(';\n').filter((v) => v.length > 0);

        if (results.length <= 0) {
            resetSearch();
            return;
        }

        if (lastSearchRequest !== request) {
            lastSearchIndex = -1;
            resetSearchMarks();
        }
        lastSearchRequest = request;

        lastSearchIndex += direction;
        if (lastSearchIndex < 0) {
            lastSearchIndex = results.length - 1;
        }
        if (lastSearchIndex >= results.length) {
            lastSearchIndex = 0;
        }

        searchInfo.innerText = `(${lastSearchIndex + 1}/${results.length})`;

        for (let i = 0; i < results.length; i++) {
            markAsFound(results[i], i === lastSearchIndex);
        }
    }

    function markAsFound(path, isCurrent) {
        const pathItems = path.split('/');
        let subPath = '';
        for (const i in pathItems) {
            if (i === 0 || i === '0') continue;

            subPath += `/${pathItems[i]}`;
            const keyItem = findKeyElement(subPath);
            const groupItem = findGroupElement(subPath);
            if (keyItem != null) {
                if (isCurrent && groupItem != null) {
                    if (isCollapsed(groupItem)) {
                        keyItem.onclick(null);
                    }
                }
            }
        }

        if (isCurrent) {
            const lastFoundCurrent = document.getElementsByClassName('found_current');
            for (let i = 0; i < lastFoundCurrent.length; i++) {
                lastFoundCurrent[i].classList.remove('found_current');
            }
            markKeySelected(path);
        }

        const valueItem = findValueElement(path);
        if (valueItem !== null) {
            if (isCurrent) {
                valueItem.classList.add('found', 'found_current');
                if (!isOnScreen(valueItem)) {
                    valueItem.scrollIntoView({block: 'center'});
                }
            } else {
                valueItem.classList.add('found');
            }
        } else {
            const keyItem = findKeyElement(path);
            if (keyItem !== null) {
                if (isCurrent) {
                    keyItem.classList.add('found', 'found_current');
                    if (!isOnScreen(keyItem)) {
                        keyItem.scrollIntoView({block: 'center'});
                    }
                } else {
                    keyItem.classList.add('found');
                }
            }
        }
    }

    function switchToTextView() {
        const displayJSONButton = document.getElementById('displayJSON-button');
        displayJSONButton.innerText = "Display JSON";
        document.getElementById('formatJSON-button').classList.remove('gone');
        document.getElementById('toText-button').classList.add('gone');
        document.getElementById('search-box').classList.add('gone');
        document.getElementById('settings-box').classList.add('gone');
        document.getElementById('hints').classList.add('gone');
        document.getElementById('json-display').classList.add('gone');
        const input = document.getElementById('json-input');
        input.classList.remove('gone');
        updatePathInfo('');
    }

    function switchToJsonView() {
        const input = document.getElementById('json-input');
        const display = document.getElementById('json-display');
        display.classList.remove('gone');
        input.classList.add('gone');
        const displayJSONButton = document.getElementById('displayJSON-button');
        displayJSONButton.innerText = "Reset";
        document.getElementById('search-box').classList.remove('gone');
        document.getElementById('settings-box').classList.remove('gone');
        document.getElementById('hints').classList.remove('gone');
        document.getElementById('formatJSON-button').classList.add('gone');
        document.getElementById('toText-button').classList.remove('gone');
        updatePathInfo('');
    }

    function toText() {
        switchToTextView();
        const input = document.getElementById('json-input');
        input.value = jsonString;
        formatJSON();
    }

    function loadFile() {
        const fileInput = document.getElementById("filename");
        const fileContent = document.getElementById("json-input");
        if (fileInput.files && fileInput.files[0]) {
            const reader = new FileReader();
            reader.onload = function (e) {
                fileContent.value = e.target.result;
            };
            reader.readAsText(fileInput.files[0]);
            switchToTextView();
        } else {
            alert("Пожалуйста, выберите файл.");
        }
    }

    function gotoParent(
        path = selectedPath,
        action = (parentPath) => {
            markKeySelected(parentPath);
        },
    ) {
        if (path != null) {
            const parentPath = getParentPath(path);
            if (parentPath !== path) {
                action(parentPath);
            }
        }
    }

    function gotoFirstChild(path = selectedPath, index = 0) {
        if (path != null) {
            const groupElement = findGroupElement(path);
            if (groupElement != null) {
                const children = groupElement.children;
                if (children != null && children.length > 0) {
                    const firstChild = children[(index >= 0) ? index : (children.length - 1)];
                    if (firstChild != null) {
                        const firstChildId = firstChild.id;
                        if (firstChildId != null) {
                            const firstChildPath = elementIdToPath(firstChildId);
                            markKeySelected(firstChildPath);
                        }
                    }
                }
            }
        }
    }

    function gotoNextInParent(inc, path = selectedPath) {
        if (inc < 0) {
            gotoParent(path);
        } else {
            gotoParent(path, (parentPath) => {
                gotoDownOrUp(1, false, parentPath);
            });
        }
    }

    function gotoDownOrUp(
        inc,
        isGoInside,
        path = selectedPath,
        action = (nextPath) => {
            const groupElement = findGroupElement(nextPath);
            if (isGoInside && inc < 0 && !isCollapsed(groupElement) && groupElement.childElementCount > 0) {
                gotoFirstChild(nextPath, -1);
            } else {
                markKeySelected(nextPath);
            }
        },
        failAction = (path) => {
            gotoNextInParent(inc, path);
        }
    ) {
        if (path != null) {
            const groupElement = findGroupElement(path);
            if (isGoInside && inc > 0 && !isCollapsed(groupElement) && groupElement.childElementCount > 0) {
                gotoFirstChild(path);
            } else {
                const keyElement = findKeyElement(path);
                const myLevel = getLevelByPath(path);
                if (keyElement != null) {
                    const myGroupElement = keyElement.parentElement;
                    if (myGroupElement != null) {
                        const myGroupId = myGroupElement.id;
                        const parentGroupElement = myGroupElement.parentElement;
                        if (parentGroupElement != null) {
                            const keyElements = Array.from(parentGroupElement.getElementsByClassName('json-container'))
                                .filter(item => {
                                    const itemId = item.id;
                                    const itemPath = elementIdToPath(itemId);
                                    const level = getLevelByPath(itemPath);
                                    return level === myLevel;
                                });
                            if (keyElements != null && keyElements.length > 1) {
                                const myIndex = keyElements.findIndex(element => element.id === myGroupId);
                                if (myIndex >= 0) {
                                    const nextIndex = myIndex + inc;
                                    if (nextIndex >= 0 && nextIndex < keyElements.length) {
                                        const nextKeyElement = keyElements[nextIndex];
                                        if (nextKeyElement != null) {
                                            const nextPath = elementIdToPath(nextKeyElement.id);
                                            action(nextPath)
                                        }
                                    } else {
                                        failAction(path);
                                    }
                                }
                            } else {
                                failAction(path);
                            }
                        }
                    }
                }
            }
        }
    }

    function jsonDisplayKeyPressed(keyEvent) {
        const keysMap = {
            ArrowLeft: (isCtrlPressed) => {
                keyEvent.preventDefault();
                makeExpandCollapseByPath(false, selectedPath, () => {
                    gotoParent();
                });
            },
            ArrowUp: (isCtrlPressed) => {
                keyEvent.preventDefault();
                gotoDownOrUp(-1, !isCtrlPressed);
            },
            ArrowRight: (isCtrlPressed) => {
                keyEvent.preventDefault();
                makeExpandCollapseByPath(true, selectedPath, () => {
                    gotoFirstChild();
                });
            },
            ArrowDown: (isCtrlPressed) => {
                keyEvent.preventDefault();
                gotoDownOrUp(1, !isCtrlPressed);
            }
        };
        const action = keysMap[keyEvent.code];
        if (action != null) {
            const isCtrlPressed = keyEvent.shiftKey || keyEvent.altKey || keyEvent.ctrlKey || keyEvent.metaKey;
            action(isCtrlPressed);
        }
    }

    let selectedPath = null;

    function markKeySelected(path) {
        if (path != null && path !== '') {
            const newSelectedElement = findRootElement(path);
            if (selectedPath != null) {
                const lastSelectedElement = findRootElement(selectedPath);
                if (lastSelectedElement != null) {
                    lastSelectedElement.classList.remove('json-root-selected');
                }
            }
            if (newSelectedElement != null) {
                newSelectedElement.classList.add('json-root-selected');
            }

            selectedPath = path;

            updatePathInfo(selectedPath);

            if (!isOnScreen(newSelectedElement)) {
                newSelectedElement.scrollIntoView({block: 'center'});
            }
        }
    }

    function updatePathInfo(path) {
        const pathElement = document.getElementById('path-info');
        if (pathElement != null && path != null) {
            if (path.length === 0) {
                pathElement.innerText = '\xa0';
            } else {
                pathElement.innerText = path;
            }
        }
    }

    let json;
    let jsonString = '';

    function displayJSON() {
        const input = document.getElementById('json-input');

        try {
            json = JSON.parse(input.value);
        } catch (e) {
            alert('Invalid JSON');
            return;
        }
        jsonString = JSON.stringify(json);

        const display = document.getElementById('json-display');
        display.innerHTML = '';
        lastSearchRequest = '';
        let sizeOut = {
            value: 0
        };
        display.appendChild(createTreeElement('', '', json, sizeOut, jsonString.length));
        display.normalize();

        switchToJsonView();
    }

    function init() {
        document.onkeydown = (event) => {
            const display = document.getElementById('json-display');
            if (display === document.activeElement) {
                jsonDisplayKeyPressed(event);
            }
        };

        const searchInput = document.getElementById('search-input');
        searchInput.onkeydown = (event) => {
            if (event.key === 'Enter') {
                search();
            }
        };

        const pathInfo = document.getElementById('path-info');
        pathInfo.onclick = () => {
            copyToClipboard(pathInfo.innerText);
        };

        const isShowInfo = document.getElementById('is-show-info');
        isShowInfo.onclick = () => {
            updateInfoVisibility(document, isShowInfo.checked);
        }

        const isSortingBySize = document.getElementById('is-sorting-by-size');
        isSortingBySize.onclick = () => {
            displayJSON();
        }

        const isCaseSensitiveSearch = document.getElementById('is-search-case-sensitive');
        isCaseSensitiveSearch.onclick = () => {
            search();
        }
    }

    init();
    switchToTextView();
</script>
<script src="unit_tests.js"></script>
</body>
</html>
