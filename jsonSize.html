<!DOCTYPE html>
<!--suppress CssUnusedSymbol, HtmlFormInputWithoutLabel -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSON Size</title>
    <style>
        html {
            font-family: Arial, sans-serif;
            font-size: 1.3em;
            background-color: #999;
            overflow: hidden;
        }

        body {
            margin: 0;
            padding: 0;
        }

        textarea {
            width: 100%;
            height: 150px;
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: monospace;
        }

        .main-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .top-panel {
            width: 100vw;
            font-size: 0.7rem;
            background-color: #ccc;
            outline: #e2e2e2 groove medium;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        button {
            padding: 10px 15px;
            background-color: #61afef;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            margin: 0.5rem 0 0.5rem 0.5rem;
        }

        button:hover {
            background-color: #4a90e2;
        }

        .search-box {
            display: flex;
            flex-direction: row;
            align-items: center;
        }

        .find-button {
            height: 30px;
            width: 30px;
            padding: 0;
            margin: 0;
        }

        .find-info {
            padding: 0;
            margin: 0 0.2rem;
        }

        .find-input {
            width: 15vw;
            padding: 10px 6px;
            margin: 0 0.5rem;
        }

        .filename {
            width: 20vw;
            height: 100%;
            cursor: pointer;
            color: #1654a3;
            font-weight: bold;
            padding: 0.9rem;
            margin: 0 0 0 0.5rem;
            outline: #e2e2e2 groove medium;
        }

        .filename:hover {
            color: #338cff;
        }

        .hints {
            width: 13rem;
            height: 100%;
            font-size: 0.6rem;
            line-height: 0.1rem;
            padding: 0 1rem;
            margin: 0;
            outline: #e2e2e2 groove medium;
        }

        .path {
            color: #1654a3;
            font-weight: bold;
            font-size: 0.7rem;
            padding: 0.2rem 20px;
            margin: 0;
        }

        .bottom-panel {
            width: 96.4vw;
            flex-grow: 1;
            overflow: auto;
            margin: 0 0.5vw 0.5vw;
            border: 0.3vw solid #444;
            border-radius: 18px;
            outline: #e2e2e2 groove medium;
        }

        .json-input {
        }

        .json-display {
            white-space: pre;
            font-family: monospace;
            background-color: #282c34;
            padding: 1vw;
            color: #f8f8f2;
        }

        .json-display:focus {
            border-color: #1111c6;
        }

        .json-container {
            width: fit-content;
            min-width: 96.4vw;
        }

        .json-margin {
            color: #999999;
        }

        .json-key-group {
            cursor: pointer;
            color: #ffe2e3;
            font-weight: bold;
        }

        .json-key-group:hover {
            color: #62a6ff;
        }

        .json-key-value {
            cursor: pointer;
            color: #7da762;
        }

        .json-key-value:hover {
            font-weight: bold;
        }

        .json-key-selected {
            background-color: #000;
            outline: #FFF dotted thin;
        }

        .json-border {
            cursor: pointer;
            color: #ff989f;
            font-weight: bold;
        }

        .json-border-clickable {
            cursor: pointer;
            color: #ff989f;
            font-weight: bold;
        }

        .json-border-clickable:hover {
            color: #338cff;
        }

        .json-number {
            color: #96ceff;
        }

        .json-string {
            color: #7fb1d5;
        }

        .json-string-clickable {
            cursor: pointer;
            color: #d57f7f;
        }

        .json-string-clickable:hover {
            color: #338cff;
        }

        .json-info-group-huge {
            color: #ff0000;
            font-weight: bold;
        }

        .json-info-group-big {
            color: #ff0000;
        }

        .json-info-group-middle {
            color: #ffde00;
        }

        .json-info-group-small {
            color: #31ad00;
        }

        .json-info-group-tiny {
            color: #4f7640;
        }

        .json-duplication {
            cursor: pointer;
            color: #ffde00;
            font-weight: bold;
            margin-left: 16px;
        }

        .json-duplication:hover {
            color: #338cff;
        }

        .found {
            outline: #00ffed dashed thin;
        }

        .found_current {
            font-weight: bold;
            color: white;
            background-color: #000;
            padding-top: 2px;
            padding-bottom: 2px;
            outline-style: solid;
        }

        .json-placeholder-button {
        }

        .json-placeholder-button::before {
            content: ' ';
        }

        .json-copy-button {
            cursor: pointer;
            color: #ffffff;
        }

        .json-copy-button::before {
            content: '\00A9';
        }

        .gone {
            display: none;
        }

        .no-select {
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* Internet Explorer/Edge */
            user-select: none; /* Стандартное свойство */
        }

        .invisible {
            color: transparent;
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* Internet Explorer/Edge */
            user-select: none; /* Стандартное свойство */
        }

        .toast {
            position: fixed;
            left: 45%;
            bottom: 10%;
            z-index: 1;

            opacity: 0;
            transition: opacity 0.5s ease-in-out;

            background-color: #eee;
            border: 1px solid #ccc;
            border-radius: 18px;
            outline: #e2e2e2 groove medium;
            padding: 15px;
        }

        .toast-visible {
            opacity: 1;
        }
    </style>
</head>
<body>
<div class="main-container">
    <div class="top-panel">
        <div>
            <button id="displayJSON-button" onclick="displayJSON()">Display JSON</button>
            <button id="formatJSON-button" onclick="formatJSON()">Format</button>
            <button id="toText-button" onclick="toText()">to Text</button>
        </div>
        <div id="search-box" class="search-box">
            <input id="find-input" class="find-input" placeholder="Search by key or value. (not both at once)">
            <button id="find-back-button" class="find-button" onclick="search(-1)">&#9664;</button>
            <p id="find-info" class="find-info">&nbsp;&nbsp;-&nbsp;&nbsp;</p>
            <button id="find-button" class="find-button" onclick="search()">&#9654;</button>
        </div>
        <div>
            <input id="filename" class="filename" type="file" onchange="loadFile()"/>
        </div>
        <div></div>
        <div></div>
        <div id="hints" class="hints">
            <p><b>Left click</b> - expand/collapse the node.</p>
            <p><b>Right click</b> - focus on the selected node.</p>
            <p>You can use <b>arrows</b> to navigate</p>
        </div>
    </div>

    <p id="path" class="path">&nbsp;</p>

    <div id="json-display" class="json-display bottom-panel" tabindex="0"></div>

    <textarea id="json-input" class="json-input bottom-panel" placeholder="Paste your JSON here...">{
    "name": "John",
    "age": 30,
    "married": true,
    "children": [
        {
            "name": "Jane",
            "age": 10
        },
        {
            "name": "Mark",
            "age": 5
        }
    ],
    "pets": [],
    "address": {
        "street": "123 Main St",
        "city": "New York",
        "zip": {
            "num": 10001,
            "str": "10001"
        }
    }
}</textarea>
</div>

<div id="toast" class="toast"></div>

<script>
    const INDENT_SPACES = 4;
    const LINE_SYMBOL = '·' + ' '.repeat(INDENT_SPACES - 1); // '·' U+00B7 &#183; \00B7  |  '—' U+2014 &#8212; \2014
    const BUTTONS_WIDTH = 0;
    const STRING_LENGTH_LIMIT = 160;
    const STRING_LENGTH_CUT = 80;
    const STRING_SUB_LENGTH = STRING_LENGTH_CUT;

    function pair(a, b) {
        return {first: a, second: b};
    }

    function countOf(string, substring) {
        let count = -1;
        let index = -1;
        do {
            index = string.indexOf(substring, index + 1);
            count++;
        } while (index >= 0);

        return count;
    }

    function isOnScreen(item) {
        const topMargin = 70;
        const rect = item.getBoundingClientRect();
        return rect.top >= topMargin && rect.left >= 0 && rect.bottom <= window.innerHeight && rect.right <= window.innerWidth;
    }

    function formatBytes(bytes) {
        if (bytes < 1024) {
            return bytes + " bytes";
        } else if (bytes < 1048576) {
            return (bytes / 1024).toFixed(2) + " KB";
        } else if (bytes < 1073741824) {
            return (bytes / 1048576).toFixed(2) + " MB";
        } else {
            return (bytes / 1073741824).toFixed(2) + " GB";
        }
    }

    function formatPercent(bytes, fullSize) {
        return (bytes * 100.0 / fullSize).toFixed(2) + '%';
    }

    function copyToClipboard(str) {
        navigator.clipboard.writeText(str).then(() => {
            showToast('Copied to clipboard...');
        }, (err) => {
            showToast('An error occurred while copying the text: ', err);
        });
    }

    function showToast(message) {
        const toast = document.getElementById('toast');
        toast.innerText = message
        toast.classList.add('toast-visible');
        setTimeout(function () {
            toast.classList.remove('toast-visible');
        }, 1000);
    }

    function getShortString(str) {
        return `"${str.replace('\n', '\\n').substring(0, STRING_LENGTH_CUT - 3)}..."`
    }

    function getFormattedString(str, margin = '') {
        let result = [];
        for (let i = 0; i < str.length; i += STRING_SUB_LENGTH) {
            result.push(str.slice(i, i + STRING_SUB_LENGTH));
        }
        return '"' + result.slice(0, result.length - 1).map((it) => {
            return it + '\n' + margin;
        }).join('') + result[result.length - 1] + '"';
    }

    function getParentPath(path) {
        const split = path.split('/');
        return split.slice(0, split.length - 1).join('/');
    }

    function elementIdToPath(keyId) {
        if (keyId != null && keyId.length > 0) {
            const split = keyId.split('(');
            if (split != null && split.length > 1) {
                const split2 = split[1].split(')');
                if (split2 != null && split2.length > 0) {
                    return split2[0];
                }
            }
        }
        return null;
    }

    function getLevelByPath(path) {
        if (path != null) {
            return path.split('/').length;
        }
        return 0;
    }

    function getRootId(path) {
        return `ROOT(${path})`;
    }

    function getKeyId(path) {
        return `KEY(${path})`;
    }

    function getGroupKey(path) {
        return `GROUP(${path})`;
    }

    function getValueKey(path) {
        return `VALUE(${path}/VALUE)`;
    }

    function findRootElement(path) {
        return document.getElementById(getRootId(path));
    }

    function findKeyElement(path) {
        return document.getElementById(getKeyId(path));
    }

    function findGroupElement(path) {
        return document.getElementById(getGroupKey(path));
    }

    function findValueElement(path) {
        return document.getElementById(getValueKey(path));
    }

    function createTreeElement(path, key, value, sizeOut, fullSize, level = 0, isLast = true, isParentArray = false) {
        const isGroup = typeof value === 'object' && value !== null;
        const isArray = Array.isArray(value);

        const indentSpaces = BUTTONS_WIDTH + level * INDENT_SPACES;
        const marginBegin = dotLine(indentSpaces + (isGroup ? -BUTTONS_WIDTH : 0));

        const pathElement = document.getElementById('path');
        const container = document.createElement('div');
        container.classList.add('json-container');
        container.id = getRootId(path);
        const copyButton = document.createElement('span');
        copyButton.classList.add('json-copy-button');
        const keyElement = document.createElement('span');
        keyElement.id = getKeyId(path);
        const marginElement = document.createElement('span');
        marginElement.classList.add('json-margin');
        const infoMarginElement = document.createElement('span');
        infoMarginElement.classList.add('json-margin');
        const infoElement = document.createElement('span');

        const keyStr = key ? `${key}` : '';
        const delimStr = key ? `: ` : '';
        const keySize = (key && !isParentArray) ? 1/*"*/ + key.length + 1/*"*/ + 1/*:*/ : 0;
        const mySize = keySize + calculateJsonSize(value) + (isLast ? 0 : 1)/*,*/;
        sizeOut.value = mySize;

        let beforeInfoLen = marginBegin.length + keyStr.length + delimStr.length;
        marginElement.textContent = marginBegin

        keyElement.onmousemove = () => {
            if (path.length > 0) {
                pathElement.innerText = path;
            }
        }
        marginElement.onmousemove = keyElement.onmousemove;
        infoMarginElement.onmousemove = keyElement.onmousemove;
        infoElement.onmousemove = keyElement.onmousemove;

        if (isGroup) {
            keyElement.classList.add('json-key-group');
            keyElement.textContent = keyStr;
            const borderElement = document.createElement('span');
            borderElement.classList.add('json-border');
            const valueElement = document.createElement('div');
            valueElement.id = getGroupKey(path);
            const closureInlineElement = document.createElement('span');
            closureInlineElement.classList.add('json-border');
            const closureMarginElement = document.createElement('span');
            closureMarginElement.classList.add('json-margin');
            const placeholderButton = document.createElement('span');
            placeholderButton.classList.add('json-placeholder-button');
            const closureElement = document.createElement('span');
            closureElement.classList.add('json-border-clickable');

            // ---

            if (level === 0) {
                appendValueChildren(path, value, valueElement, fullSize, level, isArray);
            }
            const closureElements = [valueElement, closureMarginElement, closureElement];
            const closureElementsNegative = [closureInlineElement];
            onExpandCollapse(level === 0, closureElements, closureElementsNegative);

            keyElement.onclick = () => {
                const toExpand = isCollapsed(valueElement);
                makeExpandCollapse(toExpand, path, value, fullSize, level, isArray, valueElement, closureElements, closureElementsNegative);
                markKeySelected(path);
            };
            borderElement.onclick = keyElement.onclick;
            closureInlineElement.onclick = keyElement.onclick;
            closureElement.onclick = keyElement.onclick;
            marginElement.onclick = () => {
                markKeySelected(path);
            };
            infoMarginElement.onclick = marginElement.onclick;
            infoElement.onclick = marginElement.onclick;

            borderElement.onmousemove = keyElement.onmousemove;
            closureInlineElement.onmousemove = keyElement.onmousemove;
            closureElement.onmousemove = keyElement.onmousemove;

            keyElement.oncontextmenu = () => {
                focusThis(path, key, value);
                markKeySelected(path);
                return false;
            };

            const childCount = Object.keys(value).length;
            const borderStartStr = isArray ? '[' : '{';
            beforeInfoLen += BUTTONS_WIDTH + borderStartStr.length + `${childCount}`.length + 2/*},*/;

            borderElement.textContent = delimStr + borderStartStr;
            closureInlineElement.textContent = childCount + (isArray ? ']' : '}') + ',';
            closureMarginElement.textContent = dotLine(indentSpaces);
            closureElement.textContent = (isArray ? ']' : '}') + ',';

            // ---
            container.appendChild(copyButton);
            container.appendChild(marginElement);
            container.appendChild(keyElement);
            container.appendChild(borderElement);
            container.appendChild(closureInlineElement);
            container.appendChild(infoMarginElement);
            container.appendChild(infoElement);
            container.appendChild(valueElement);
            container.appendChild(placeholderButton);
            container.appendChild(closureMarginElement);
            container.appendChild(closureElement);
        } else {
            const valueElement = document.createElement('span');
            valueElement.id = getValueKey(path);
            const duplicationElement = document.createElement('span');
            duplicationElement.classList.add('json-duplication', 'no-select');

            keyElement.onclick = () => {
                markKeySelected(path);
            };
            valueElement.onclick = keyElement.onclick;
            marginElement.onclick = keyElement.onclick;
            infoMarginElement.onclick = keyElement.onclick;
            infoElement.onclick = keyElement.onclick;

            valueElement.onmousemove = keyElement.onmousemove;

            let valueStr;
            let duplicationStr = '';
            if (typeof value === 'string') {
                if (value.length > STRING_LENGTH_LIMIT) {
                    valueElement.classList.add('json-string-clickable');
                    valueStr = getShortString(value);
                    valueElement.onclick = () => {
                        const textContent = valueElement.textContent;
                        if (textContent.length < value.length) {
                            const additionalMargins = (keyStr.length + delimStr.length + 1/*"*/) / INDENT_SPACES;
                            valueElement.textContent = getFormattedString(
                                value, marginBegin + dotLine(BUTTONS_WIDTH + additionalMargins * INDENT_SPACES)
                            );
                        } else if (textContent.includes('\n')) {
                            valueElement.textContent = `"${value}"`;
                        } else {
                            valueElement.textContent = getShortString(value);
                        }
                        markKeySelected(path);
                    };
                } else {
                    valueElement.classList.add('json-string');
                    valueStr = `"${value}"`;
                }
                valueStr += (isLast ? '' : ',');

                if (value.length > 0) {
                    try {
                        const count = countOf(jsonString, `${value}`)
                        if (count > 1) {
                            duplicationStr += 'Duplication: ' + count + ' times.';
                            duplicationElement.onclick = () => {
                                const findInput = document.getElementById('find-input');
                                if (findInput != null && findButton != null) {
                                    findInput.value = `${value}`;
                                    search();
                                }
                                markKeySelected(path);
                            };
                        }
                    } catch (e) {
                        duplicationStr += 'Exception: ' + e.toString();
                    }
                }
            } else {
                valueElement.classList.add('json-number');
                valueStr = value + ',';
            }
            beforeInfoLen += valueStr.length;

            // ---
            keyElement.classList.add('json-key-value');
            keyElement.textContent = keyStr + delimStr;

            valueElement.textContent = valueStr;

            container.appendChild(copyButton);
            container.appendChild(marginElement);
            container.appendChild(keyElement);
            container.appendChild(valueElement);
            container.appendChild(infoMarginElement);
            container.appendChild(infoElement);

            if (duplicationStr.length > 0) {
                duplicationElement.textContent = duplicationStr;
                container.appendChild(duplicationElement);
            }
        }

        copyButton.onclick = () => {
            copyToClipboard(keyStr + delimStr + JSON.stringify(value));
        }

        const infoBytes = formatBytes(mySize);
        infoMarginElement.textContent = marginAlignmentRight(infoBytes, beforeInfoLen);
        infoElement.textContent = infoBytes + ' | ' + formatPercent(mySize, fullSize);
        setInfoClass(infoElement, mySize, fullSize);

        return container;
    }

    function isCollapsed(groupItem) {
        if (groupItem != null) {
            return groupItem.classList.contains('gone');
        } else return true;
    }

    function appendValueChildren(path, value, valueElement, fullSize, level, isArray) {
        const count = Object.keys(value).length;
        let i = 0;
        const valueChildren = [];
        const childrenSize = {
            value: 0
        };
        for (const k in value) {
            childrenSize.value = 0;
            const isLastChild = i === count - 1;
            const newPath = `${path}/${k}`;
            const child = createTreeElement(newPath, k, value[k], childrenSize, fullSize, level + 1, isLastChild, isArray)
            valueChildren.push(pair(childrenSize.value, child));
            i++;
        }
        valueChildren
            .sort((a, b) => b.first - a.first)
            .forEach((it) => {
                valueElement.appendChild(it.second);
            });
    }

    function onExpandCollapse(toExpand, closureElements, closureElementsNegative) {
        if (toExpand) {
            closureElements.forEach((it) => {
                it.classList.remove('gone');
            });
            closureElementsNegative.forEach((it) => {
                it.classList.add('invisible');
            });
        } else {
            closureElements.forEach((it) => {
                it.classList.add('gone');
            });
            closureElementsNegative.forEach((it) => {
                it.classList.remove('invisible');
            });
        }
    }

    function makeExpandCollapse(toExpand, path, value, fullSize, level, isArray, valueElement, closureElements, closureElementsNegative) {
        if (toExpand && !valueElement.hasChildNodes()) {
            appendValueChildren(path, value, valueElement, fullSize, level, isArray);
        }
        onExpandCollapse(toExpand, closureElements, closureElementsNegative);
    }

    function makeExpandCollapseByPath(
        toExpand,
        path,
        nextAction = () => {
        }
    ) {
        if (path != null) {
            const keyElement = findKeyElement(path);
            if (keyElement != null) {
                const groupElement = findGroupElement(path);
                if (groupElement != null) {
                    if (isCollapsed(groupElement) === toExpand) {
                        keyElement.onclick(null);
                    } else {
                        nextAction();
                    }
                } else {
                    if (!toExpand) {
                        nextAction();
                    }
                }
            }
        }
    }

    function setInfoClass(infoElement, mySize, fullSize) {
        if (mySize > fullSize / 2) {
            infoElement.classList.add('json-info-group-huge');
        } else if (mySize > fullSize / 5) {
            infoElement.classList.add('json-info-group-big');
        } else if (mySize > fullSize / 7) {
            infoElement.classList.add('json-info-group-middle');
        } else if (mySize > fullSize / 10) {
            infoElement.classList.add('json-info-group-small');
        } else {
            infoElement.classList.add('json-info-group-tiny');
        }
    }

    function getInfoMarginSz(beforeInfo, infoMod = 20) {
        const beforeInfoMod = Math.floor(beforeInfo / infoMod + 1) * infoMod;
        return beforeInfoMod - beforeInfo;
    }

    function calculateJsonSize(jsonData) {
        const jsonStr = JSON.stringify(jsonData);
        return jsonStr.length;
    }

    let longDotLine = '';
    const oneLen = LINE_SYMBOL.length;

    function dotLine(charCount, fromStart = 0) {
        if (charCount === 0) return '';
        const fullLen = fromStart + charCount;
        if (longDotLine.length < fullLen) {
            longDotLine = LINE_SYMBOL.repeat(fullLen / oneLen + oneLen);
        }
        return longDotLine.substring(fromStart, fullLen - 1) + ' ';
    }

    function marginAlignmentRight(str, fromStart) {
        const extPadding = getInfoMarginSz(fromStart);
        const fullWidth = 16;
        const padding = Math.max(fullWidth - str.length, 0);
        return dotLine(padding + extPadding, fromStart);
    }

    function focusThis(path, key, node) {
        const display = document.getElementById('json-display');
        jsonString = `{"${key}":${JSON.stringify(node)}}`;
        try {
            json = JSON.parse(jsonString);
        } catch (e) {
            alert('Invalid JSON');
            return;
        }
        display.innerHTML = '';
        lastSearchRequest = '';
        let size = {
            value: 0
        };
        display.appendChild(createTreeElement('', '', json, size, jsonString.length));
    }

    function formatJSON() {
        const input = document.getElementById('json-input');

        let json;
        try {
            json = JSON.parse(input.value);
        } catch (e) {
            alert('Invalid JSON');
            return;
        }

        input.value = JSON.stringify(json, null, ' ');
    }

    function findInJson(json, str, path = '') {
        let result = '';
        const isArray = Array.isArray(json);

        for (const key in json) {
            const newPath = `${path}/${key}`;
            const value = json[key];
            if (!isArray && key.toUpperCase().includes(str)) {
                result += `${newPath};\n`;
            }
            const isGroup = typeof value === 'object' && value !== null;
            if (isGroup) {
                result += findInJson(value, str, newPath);
            } else {
                if (`${value}`.toUpperCase().includes(str)) {
                    result += `${newPath}/VALUE;\n`;
                }
            }
        }

        return result;
    }

    let lastSearchRequest = '';
    let lastSearchIndex = -1;

    function search(direction = 1) {
        const findInput = document.getElementById('find-input');
        const findBackButton = document.getElementById('find-back-button');
        const findInfo = document.getElementById('find-info');
        const findButton = document.getElementById('find-button');
        const request = findInput.value;
        if (request.length === 0) return;
        const results = findInJson(json, request.toUpperCase()).split(';\n').filter((v) => v.length > 0);

        if (lastSearchRequest !== request) {
            lastSearchIndex = -1;

            const lastFound = document.getElementsByClassName('found');
            for (let i = 0; i < lastFound.length; i++) {
                try {
                    lastFound[i].classList.remove('found_current', 'found');
                    lastFound[i].classList.remove('found_current', 'found');
                    lastFound[i].classList.remove('found_current', 'found');
                    lastFound[i].classList.remove('found_current', 'found');
                } catch (e) {
                }
            }
        }
        lastSearchRequest = request;

        lastSearchIndex += direction;
        if (lastSearchIndex < 0) {
            lastSearchIndex = results.length - 1;
        }
        if (lastSearchIndex >= results.length) {
            lastSearchIndex = 0;
        }
        if (results.length <= 1) {
            findButton.innerText = 'Search';
            findBackButton.classList.add('gone');
            findInfo.classList.add('gone');
        } else {
            findInfo.innerText = `(${lastSearchIndex + 1}/${results.length})`;
            findButton.innerText = `\u25B6`;
            findBackButton.innerText = `\u25C0`;
            findBackButton.classList.remove('gone');
            findInfo.classList.remove('gone');
        }

        if (results.length > lastSearchIndex) {
            for (let i = 0; i < results.length; i++) {
                markAsFound(results[i], i === lastSearchIndex);
            }
        }
    }

    function markAsFound(path, isCurrent) {
        const pathItems = path.split('/');
        let subPath = '';
        for (const i in pathItems) {
            if (i === 0 || i === '0') continue;

            subPath += `/${pathItems[i]}`;
            const keyItem = findKeyElement(subPath);
            const groupItem = findGroupElement(subPath);
            if (keyItem != null) {
                if (isCurrent && groupItem != null) {
                    if (isCollapsed(groupItem)) {
                        keyItem.onclick(null);
                    }
                }
            }
        }

        if (isCurrent) {
            const lastFoundCurrent = document.getElementsByClassName('found_current');
            for (let i = 0; i < lastFoundCurrent.length; i++) {
                lastFoundCurrent[i].classList.remove('found_current');
            }
        }

        const valueItem = document.getElementById(`VALUE(${path})`);
        if (valueItem !== null) {
            if (isCurrent) {
                valueItem.classList.add('found', 'found_current');
                if (!isOnScreen(valueItem)) {
                    valueItem.scrollIntoView({block: 'center'});
                }
            } else {
                valueItem.classList.add('found');
            }
        } else {
            const keyItem = findKeyElement(path);
            if (keyItem !== null) {
                if (isCurrent) {
                    keyItem.classList.add('found', 'found_current');
                    if (!isOnScreen(keyItem)) {
                        keyItem.scrollIntoView({block: 'center'});
                    }
                } else {
                    keyItem.classList.add('found');
                }
            }
        }
    }

    function switchToTextView() {
        const displayJSONButton = document.getElementById('displayJSON-button');
        displayJSONButton.innerText = "Display JSON";
        document.getElementById('formatJSON-button').classList.remove('gone');
        document.getElementById('toText-button').classList.add('gone');
        document.getElementById('search-box').classList.add('gone');
        document.getElementById('hints').classList.add('gone');
        document.getElementById('json-display').classList.add('gone');
        const input = document.getElementById('json-input');
        input.classList.remove('gone');
    }

    function switchToJsonView() {
        const input = document.getElementById('json-input');
        const display = document.getElementById('json-display');
        display.classList.remove('gone');
        input.classList.add('gone');
        const displayJSONButton = document.getElementById('displayJSON-button');
        displayJSONButton.innerText = "Reset";
        document.getElementById('search-box').classList.remove('gone');
        document.getElementById('hints').classList.remove('gone');
        document.getElementById('formatJSON-button').classList.add('gone');
        document.getElementById('toText-button').classList.remove('gone');
    }

    function toText() {
        switchToTextView();
        const input = document.getElementById('json-input');
        input.value = jsonString;
        formatJSON();
    }

    function loadFile() {
        const fileInput = document.getElementById("filename");
        const fileContent = document.getElementById("json-input");
        if (fileInput.files && fileInput.files[0]) {
            const reader = new FileReader();
            reader.onload = function (e) {
                fileContent.value = e.target.result;
            };
            reader.readAsText(fileInput.files[0]);
            switchToTextView();
        } else {
            alert("Пожалуйста, выберите файл.");
        }
    }

    function gotoParent(
        path = selectedPath,
        action = (parentPath) => {
            markKeySelected(parentPath);
        },
    ) {
        if (path != null) {
            const parentPath = getParentPath(path);
            if (parentPath !== path) {
                action(parentPath);
            }
        }
    }

    function gotoFirstChild(path = selectedPath, index = 0) {
        if (path != null) {
            const groupElement = findGroupElement(path);
            if (groupElement != null) {
                const children = groupElement.children;
                if (children != null && children.length > 0) {
                    const firstChild = children[(index >= 0) ? index : (children.length - 1)];
                    if (firstChild != null) {
                        const firstChildId = firstChild.id;
                        if (firstChildId != null) {
                            const firstChildPath = elementIdToPath(firstChildId);
                            markKeySelected(firstChildPath);
                        }
                    }
                }
            }
        }
    }

    function gotoNextInParent(inc, path = selectedPath) {
        if (inc < 0) {
            gotoParent(path);
        } else {
            gotoParent(path, (parentPath) => {
                gotoDownOrUp(1, false, parentPath);
            });
        }
    }

    function gotoDownOrUp(
        inc,
        isGoInside,
        path = selectedPath,
        action = (nextPath) => {
            const groupElement = findGroupElement(nextPath);
            if (isGoInside && inc < 0 && !isCollapsed(groupElement) && groupElement.childElementCount > 0) {
                gotoFirstChild(nextPath, -1);
            } else {
                markKeySelected(nextPath);
            }
        },
        failAction = (path) => {
            gotoNextInParent(inc, path);
        }
    ) {
        if (path != null) {
            const groupElement = findGroupElement(path);
            if (isGoInside && inc > 0 && !isCollapsed(groupElement) && groupElement.childElementCount > 0) {
                gotoFirstChild(path);
            } else {
                const keyElement = findKeyElement(path);
                const myLevel = getLevelByPath(path);
                if (keyElement != null) {
                    const myGroupElement = keyElement.parentElement;
                    if (myGroupElement != null) {
                        const myGroupId = myGroupElement.id;
                        const parentGroupElement = myGroupElement.parentElement;
                        if (parentGroupElement != null) {
                            const keyElements = Array.from(parentGroupElement.getElementsByClassName('json-container'))
                                .filter(item => {
                                    const itemId = item.id;
                                    const itemPath = elementIdToPath(itemId);
                                    const level = getLevelByPath(itemPath);
                                    return level === myLevel;
                                });
                            if (keyElements != null && keyElements.length > 1) {
                                const myIndex = keyElements.findIndex(element => element.id === myGroupId);
                                if (myIndex >= 0) {
                                    const nextIndex = myIndex + inc;
                                    if (nextIndex >= 0 && nextIndex < keyElements.length) {
                                        const nextKeyElement = keyElements[nextIndex];
                                        if (nextKeyElement != null) {
                                            const nextPath = elementIdToPath(nextKeyElement.id);
                                            action(nextPath)
                                        }
                                    } else {
                                        failAction(path);
                                    }
                                }
                            } else {
                                failAction(path);
                            }
                        }
                    }
                }
            }
        }
    }

    function jsonDisplayKeyPressed(keyEvent) {
        const keysMap = {
            ArrowLeft: (isCtrlPressed) => {
                makeExpandCollapseByPath(false, selectedPath, () => {
                    gotoParent();
                });
            },
            ArrowUp: (isCtrlPressed) => {
                gotoDownOrUp(-1, !isCtrlPressed);
            },
            ArrowRight: (isCtrlPressed) => {
                makeExpandCollapseByPath(true, selectedPath, () => {
                    gotoFirstChild();
                });
            },
            ArrowDown: (isCtrlPressed) => {
                gotoDownOrUp(1, !isCtrlPressed);
            }
        };
        const action = keysMap[keyEvent.code];
        if (action != null) {
            const isCtrlPressed = keyEvent.shiftKey || keyEvent.altKey || keyEvent.ctrlKey || keyEvent.metaKey;
            action(isCtrlPressed);

            const pathElement = document.getElementById('path');
            if (pathElement != null && selectedPath != null) {
                pathElement.innerText = selectedPath;
            }
        }
    }

    let selectedPath = null;

    function markKeySelected(path) {
        if (path != null && path !== '') {
            const newSelectedElement = findRootElement(path);
            if (selectedPath != null) {
                const lastSelectedElement = findRootElement(selectedPath);
                if (lastSelectedElement != null) {
                    lastSelectedElement.classList.remove('json-key-selected');
                }
            }
            newSelectedElement.classList.add('json-key-selected');

            selectedPath = path;
        }
    }

    let json;
    let jsonString = '';

    function displayJSON() {
        const input = document.getElementById('json-input');

        try {
            json = JSON.parse(input.value);
        } catch (e) {
            alert('Invalid JSON');
            return;
        }
        jsonString = JSON.stringify(json);

        const display = document.getElementById('json-display');
        display.innerHTML = '';
        lastSearchRequest = '';
        let sizeOut = {
            value: 0
        };
        display.appendChild(createTreeElement('', '', json, sizeOut, jsonString.length));
        display.normalize();

        switchToJsonView();
    }

    function init() {
        document.onkeydown = (event) => {
            const display = document.getElementById('json-display');
            if (display === document.activeElement) {
                jsonDisplayKeyPressed(event);
            }
        };

        const findInput = document.getElementById('find-input');
        findInput.onkeydown = (event) => {
            if (event.key === 'Enter') {
                search();
            }
        };
    }

    init();
    switchToTextView();
</script>
</body>
</html>
